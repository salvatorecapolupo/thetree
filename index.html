<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8">
  <title>The Larch!</title>
  <style>
    body {
      font-family: sans-serif;
      background: #f7f7f7;
      margin: 0;
      padding: 20px;
      text-align: center;
    }

    h1 {
      margin-bottom: 10px;
    }

    #tree-container {
      position: relative;
      margin: 30px auto;
      width: 90%;
      max-width: 1200px;
    }

    #tree {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 60px;
      position: relative;
      z-index: 2;
    }

    .level {
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
      gap: 30px;
      position: relative;
    }

    .node {
      width: 150px;
      height: 50px;
      border: 2px dashed #999;
      border-radius: 10px;
      background-color: white;
      line-height: 50px;
      font-weight: bold;
      position: relative;
      z-index: 2;
    }

    .correct {
      background-color: #c4f5a2 !important;
      border-color: #58d700;
    }

    .wrong {
      background-color: #f5a2a2 !important;
      border-color: #d70000;
    }

    #bucket {
      margin-top: 40px;
      padding: 15px;
      border: 2px solid #555;
      background: #fffbe6;
      min-height: 80px;
      border-radius: 8px;
    }

    .label {
      display: inline-block;
      margin: 5px;
      padding: 6px 12px;
      background: #e2e2e2;
      border-radius: 5px;
      cursor: grab;
    }

    button {
      margin-top: 30px;
      padding: 10px 20px;
      font-size: 16px;
      cursor: pointer;
      border: none;
      background-color: #3e8ed0;
      color: white;
      border-radius: 5px;
    }

    canvas {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 1;
      pointer-events: none;
    }

  </style>
</head>
<body>
  <h1>L'albero</h1>
  <p> Trascina le etichette nel posto corretto. Tappa su "Verifica" per controllare se corretto. </p>

  <div id="tree-container">
    <canvas id="lines"></canvas>
    <div id="tree"></div>
  </div>

  <h2>La cesta</h2>
  <div id="bucket"></div>

  <button onclick="checkTree()"> &#x2705; Verifica</button>
  <button onclick="location.reload()"> &#x1F504; Riprova</button>

<div id="summary" style="margin-top: 10px; font-size: 16px;"></div>

  
  <h2>The Larch</h2>

  <img src="./the_larch.gif" alt="thhhhe laaaarch!"/> 
  
  <script>
    let correctMap = {};
    let labels = [];

    const jsonFiles = ["./albero1.json", "./albero2.json", "./albero3.json"];

    async function loadJSONTree() {
      const randomFile = jsonFiles[Math.floor(Math.random() * jsonFiles.length)];
      try {
        const res = await fetch(randomFile);
        if (!res.ok) {
          throw new Error(`HTTP error! status: ${res.status}`);
        }
        const data = await res.json();
        generateFromJSON(data);
      } catch (error) {
        console.error("Errore nel caricamento del file JSON:", error);
      }
    }


    function generateFromJSON(data) {
      const tree = document.getElementById("tree");
      const bucket = document.getElementById("bucket");
      const canvas = document.getElementById("lines");
      tree.innerHTML = "";
      bucket.innerHTML = "";
      correctMap = {};
      labels = [];

      const positions = [];
      const levels = [];

      // Livello 1: Serie
      const level1 = document.createElement("div");
      level1.className = "level";
      Object.keys(data).forEach((serie, i) => {
        const node = createDroppableNode(`L1-${i}`);
        correctMap[`L1-${i}`] = serie;
        labels.push(serie);
        level1.appendChild(node);
        positions.push({ slot: `L1-${i}`, element: node });
      });
      tree.appendChild(level1);
      levels.push(level1);

      // Livello 2: Squadre
      const level2 = document.createElement("div");
      level2.className = "level";
      let l2Count = 0;
      Object.entries(data).forEach(([serie, squadre]) => {
        Object.keys(squadre).forEach(squadra => {
          const node = createDroppableNode(`L2-${l2Count}`);
          correctMap[`L2-${l2Count}`] = squadra;
          labels.push(squadra);
          level2.appendChild(node);
          positions.push({ slot: `L2-${l2Count}`, element: node });
          l2Count++;
        });
      });
      tree.appendChild(level2);
      levels.push(level2);

      // Livello 3: Giocatori
      const level3 = document.createElement("div");
      level3.className = "level";
      let l3Count = 0;
      Object.values(data).forEach(squadre => {
        Object.values(squadre).forEach(giocatori => {
          giocatori.forEach(giocatore => {
            const node = createDroppableNode(`L3-${l3Count}`);
            correctMap[`L3-${l3Count}`] = giocatore;
            labels.push(giocatore);
            level3.appendChild(node);
            positions.push({ slot: `L3-${l3Count}`, element: node });
            l3Count++;
          });
        });
      });
      tree.appendChild(level3);
      levels.push(level3);

      // Crea le etichette
      shuffleArray(labels).forEach(text => {
        const label = document.createElement("span");
        label.className = "label";
        label.textContent = text;
        label.draggable = true;
        label.ondragstart = drag;
        bucket.appendChild(label);
      });

      setTimeout(() => drawLines(levels), 100); // Delay per avere posizione nodi
    }

    function createDroppableNode(id) {
      const node = document.createElement("div");
      node.className = "node";
      node.dataset.slot = id;
      node.textContent = "";
      node.ondragover = e => e.preventDefault();
      node.ondrop = drop;
      return node;
    }

    function drag(e) {
      e.dataTransfer.setData("text", e.target.textContent);
    }

    function drop(e) {
      e.preventDefault();
      const data = e.dataTransfer.getData("text");

      if (e.target.textContent.trim() !== "") {
        const old = e.target.textContent;
        const span = document.createElement("span");
        span.className = "label";
        span.textContent = old;
        span.draggable = true;
        span.ondragstart = drag;
        document.getElementById("bucket").appendChild(span);
      }

      e.target.textContent = data;

      [...document.querySelectorAll("#bucket .label")].forEach(el => {
        if (el.textContent === data) el.remove();
      });
    }

    function checkTree() {
      let correct = 0;
      let total = 0;
    
      // Costruisci una mappa: livello -> array di etichette corrette
      const levelMap = {};
      for (let label in correctStructure) {
        const level = correctStructure[label];
        if (!levelMap[level]) levelMap[level] = [];
        levelMap[level].push(label);
      }
    
      // Leggi gli elementi da ciascun livello nell'albero dell'utente
      const levels = document.querySelectorAll("#tree-container > div");
      levels.forEach((levelEl, levelIndex) => {
        const userLabels = Array.from(levelEl.children).map(el => el.textContent.trim());
        const expectedLabels = levelMap[levelIndex + 1] || []; // Aggiungi +1 perchÃ© levelIndex parte da 0
    
        total += expectedLabels.length;
    
        // Verifica le etichette dell'utente per ciascun livello
        userLabels.forEach(label => {
          // Cerca il nodo che contiene l'etichetta
          const labelEl = Array.from(levelEl.children).find(child => child.textContent.trim() === label);
    
          if (expectedLabels.includes(label)) {
            correct++;
            labelEl.style.backgroundColor = "lightgreen";
          } else {
            labelEl.style.backgroundColor = "lightblue";
          }
        });
      });
    
      // Suono di feedback
      const context = new AudioContext();
      const oscillator = context.createOscillator();
      oscillator.type = "square";
      oscillator.frequency.setValueAtTime(correct === total ? 880 : 220, context.currentTime);
      oscillator.connect(context.destination);
      oscillator.start();
      oscillator.stop(context.currentTime + 0.3);
    
      // Visualizza il riepilogo sotto il bottone
      const summaryElement = document.getElementById("summary");
      summaryElement.textContent = `${correct} su ${total} corretti`;
    }

    function shuffleArray(arr) {
      let array = arr.slice();
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }

    function drawLines(levels) {
      const canvas = document.getElementById("lines");
      const rect = document.getElementById("tree-container").getBoundingClientRect();
      canvas.width = rect.width;
      canvas.height = rect.height;
      const ctx = canvas.getContext("2d");
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.strokeStyle = "#aaa";
      ctx.lineWidth = 1.5;
    
      for (let i = 0; i < levels.length - 1; i++) {
        const parents = Array.from(levels[i].children);
        const children = Array.from(levels[i + 1].children);
        const ratio = Math.floor(children.length / parents.length);
    
        parents.forEach((parent, pi) => {
          const parentRect = parent.getBoundingClientRect();
          const startX = parentRect.left + parentRect.width / 2 - rect.left;
          const startY = parentRect.bottom - rect.top;
    
          for (let j = 0; j < ratio; j++) {
            const ci = pi * ratio + j;
            if (ci >= children.length) return;
            const child = children[ci];
            const childRect = child.getBoundingClientRect();
            const endX = childRect.left + childRect.width / 2 - rect.left;
            const endY = childRect.top - rect.top;
    
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
            ctx.stroke();
          }
        });
      }
    }


    function playSound(success) {
      const ctx = new (window.AudioContext || window.webkitAudioContext)();
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      osc.type = "sine";
      osc.frequency.value = success ? 880 : 220;
      gain.gain.setValueAtTime(0.2, ctx.currentTime);
      osc.connect(gain).connect(ctx.destination);
      osc.start();
      osc.stop(ctx.currentTime + 0.3);
    }

    loadJSONTree();
  </script>
</body>
</html>
